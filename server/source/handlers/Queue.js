const fs = require('fs');

const { EventEmitter } = require('events');
const { Stream } = require('stream');

const Discord = require('discord.js');
const Voice = require('@discordjs/voice');

const ffmpeg = require('ffmpeg-static');
const fluent = require('fluent-ffmpeg');

class Queue extends EventEmitter {
   constructor(client, guild) {
      super();
      this.client = client;

      this.player = null;

      this.tracks = new Discord.Collection();
      this.current = new Current();

      this.playing = false;
      this.initialized = false;

      this.guild = guild;
      this.channel = null;
      this.voice = null;

      this.repeat = 'off';
      this.volume = 0.5;

      this.buffering = false;
   }

   socket(action = 'updatePlayer', destination = this.guild.id) {
      return this.client.socket.to(destination).emit(action);
   }

   async connect(voice) {
      if (!voice) return;
      try {
         this.connection = Voice.joinVoiceChannel({
            channelId: voice.id,
            guildId: this.guild.id,
            adapterCreator: this.guild.voiceAdapterCreator,
         });
         this.voice = voice;

         this.player = Voice.createAudioPlayer({ behavior: Voice.NoSubscriberBehavior.Play });
         this.player
            .on(Voice.AudioPlayerStatus.Playing, (data) => {
               this.current.set(data.resource.metadata);
               this.current.initialize();

               this.playing = true;
               this.emit('nowPlaying', this, this.current);
               this.socket();
            })
            .on(Voice.AudioPlayerStatus.Idle, () => {
               const next = this.next();
               this.current.destroy();
               this.playing = false;
               this.socket();
               if (next) this.play(next);
               else {
                  this.emit('queueEnd', this);
               }
            })
            .on(Voice.AudioPlayerStatus.Buffering, (data) => {
               this.playing = false;
               this.socket();
            });

         this.socket();
      } catch (err) {
         this.client.logger.error(err);
      }
   }

   disconnect() {
      if (!this.voice) return;
      this.player = null;

      this.playing = false;
      this.initialized = false;

      this.channel = null;
      this.message = null;
      this.voice = null;

      this.clear();

      this.connection.destroy();

      this.emit('disconnect');
      this.socket();

      this.removeAllListeners();
   }

   move(voice) {
      this.voice = voice;
      this.socket();
   }

   handlePlayableData(playable) {}
   createAudioResource(stream, track) {}
   getAudioStream(track) {}
   getTrackData(track) {}

   async play(playable, metadata) {
      try {
         if (!playable?.id || !this.player) return;
         this.current.destroy();
         let track = this.new(playable);
         this.current.set(track);

         const tracks = JSON.parse(fs.readFileSync('tracks.json', 'utf8')) || [];
         const cached = tracks.find((item) => item.id === track.id);

         // if (cached) return this.play(this.next());

         let youtube, result;
         if (cached) {
            const channel = await this.client.channels.fetch('1343313574898040862');
            await channel.messages.fetch(cached.message);
            track = cached.track;
         } else {
            youtube = this.client.search.youtube;

            const query = `${track.name} - ${track.artist} Auto-generated by YouTube`;
            result = await youtube.get(query);
            if (!result) throw new Error('No search results found');

            result = result[0];

            track = {
               ...track,
               duration: result.duration,
               metadata: {
                  id: result.id,
                  url: result.url,
                  name: result.title,
                  duration: result.duration,
                  explicit: result.nsfw,
                  thumbnail: result.thumbnail.url,
                  artist: result.channel,
               },
               requester: metadata?.requester | null,
            };
         }

         if (this.current.initied) this.current.destroy();
         this.current.set(track);

         if (this.buffering) return;
         this.buffering = true;

         const stream = new Stream.PassThrough();
         const chunks = [];
         stream.on('data', (chunk) => chunks.push(chunk));

         if (cached) {
            const url = item.attachments.first()?.url;
            const response = await fetch(url).catch((err) => {
               console.error('Error fetching audio:', err);
               stream.destroy(err);
               return;
            });

            const reader = response.body.getReader();
            const nodeStream = new Stream.Readable({
               async read() {
                  const { done, value } = await reader.read();
                  if (done) this.push(null);
                  else this.push(Buffer.from(value));
               },
            });

            nodeStream.pipe(stream);
         } else {
            youtube.stream(result.url).pipe(stream);
         }

         const opus = fluent({ source: stream })
            .setFfmpegPath(ffmpeg)
            .format('opus')
            .on('error', (err) => {
               if (err instanceof Error && err?.message?.includes('Premature close')) return;
               console.error(err);
            });

         const resource = Voice.createAudioResource(opus.stream(), {
            inlineVolume: true,
            inputType: 'webm/opus',
            metadata: track,
         });

         this.tracks.set(track.id, track);
         this.player.play(resource);
         this.connection.subscribe(this.player);

         this.buffering = false;

         if (!cached) this.cache(track, stream, chunks);
         return track;
      } catch (erro) {
         this.buffering = false;
         console.error(erro);
      }
   }
   
   // funcção para colocar a track no cache
   async cache(track, stream, chunks) {
      if (!stream) return;
      const channel = await this.client.channels.fetch('1343313574898040862');
      await new Promise((resolve, reject) => {
         stream.on('end', resolve);
         stream.on('error', reject);
      });

      const buffered = Buffer.concat(chunks);

      if (!channel) throw new Error('Channel not found!');

      const attachment = new Discord.AttachmentBuilder(buffered, {
         name: `${track.id}.opus`,
      });
      const message = await channel.send({
         content: `${track.name} - ${track.artist}`,
         files: [attachment],
      });

      const data = {
         id: track.id,
         track: track,
         message: message.id,
      };

      const file = 'tracks.json';
      try {
         const json = fs.existsSync(file) ? JSON.parse(fs.readFileSync(file, 'utf8')) : [];
         fs.writeFileSync(file, JSON.stringify([...json, data], null, 2));
      } catch (error) {
         console.error('Erro:', error);
      }
   }
      

   new(item, options) {
      if (item.type !== 'track' && item.type !== 'playlist' && item.type !== 'album') return null;
      let track;
      if (item.type == 'playlist' || item.type == 'album') {
         let list = { ...item, requester: item?.requester };
         for (let track of list.tracks) {
            track = {
               index: this.tracks.size,
               requester: item?.requester,
               ...track,
            };
            this.tracks.set(track.id, track);
         }
         this.emit('newList', this, list);
         track = this.tracks.get(list.tracks[0].id);
      } else if (item.type == 'track') {
         track = {
            index: this.tracks.size,
            requester: options?.requester,
            ...item,
         };
         this.tracks.set(track.id, track);
         this.emit('newTrack', this, track);
      }

      this.update();
      this.socket();
      return track;
   }

   next(force = false) {
      if (this.isEnd() && !force && this.repeat == 'off') return null;
      if (this.repeat == 'track' && !force) return this.current;
      if (this.isEnd() && this.repeat == 'queue') {
         return this.tracks.at(0);
      }
      let track = this.tracks.at(this.current.index + 1);
      if (track) return track;
      else return null;
   }

   previous(force = false) {
      const start = this.current.index == 0;
      if (start && !force && this.repeat == 'off') return null;
      if (this.repeat == 'track' && !force) return this.current;
      if (start && this.repeat == 'queue') {
         return this.tracks.at(this.tracks.size - 1);
      }
      if (this.current.index - 1 >= 0) return this.tracks.at(this.current.index - 1);
      else return null;
   }

   skipTo(index) {
      if (!index) return this.current.index + 1;
      return this.play(this.tracks.at(index - 1));
   }

   remove(index) {
      const track = this.tracks.get(index);
      this.tracks.delete(index);
      if (index == this.current.index) this.play(this.next());
      this.update();
      return track;
   }

   clear() {
      this.tracks.clear();
      this.update();
      this.current.set({ index: 0 });
      this.time = 'no time';
   }

   shuffle() {
      const tracks = this.tracks.map((track) => track);
      this.tracks.clear();

      tracks.sort(() => Math.random() - 0.5);
      tracks.forEach((track, index) => {
         this.tracks.set(track.id, { ...track, index });
      });
      this.current.set(this.tracks.get(this.current.id));
      this.socket();
      return this.tracks;
   }

   order() {
      const tracks = this.tracks.map((track) => track);
      this.tracks.clear();

      tracks.sort((a, b) => a.index - b.index);
      tracks.forEach((track) => {
         this.tracks.set(this.tracks.size + 1, track);
      });
      this.update();
      this.socket();
      return this.tracks;
   }

   update() {
      const tracks = this.tracks.map((track) => track);
      this.tracks.clear();
      tracks.forEach((track) => {
         this.tracks.set(track.id, track);
      });
      return this.tracks;
   }

   isEnd() {
      return this.current.index + 1 == this.tracks.size;
   }

   setPosition(time = 0) {
      this.play(this.current);
   }

   getPosition() {
      if (!this.current?.initiedAt) return;
      const position = Date.now() - this.current.initiedAt;
      if (position > this.current.duration) return this.current.duration;
      return position;
   }

   pause() {
      this.player.pause();
      this.playing = false;
      this.socket();
   }

   unpause() {
      this.player.unpause();
      this.playing = true;
      this.socket();
   }

   setRepeat(mode) {
      this.repeat = mode;
      this.socket();
   }

   setVolume(volume) {
      this.volume = volume;
      if (this.player.state.resource) this.player.state.resource.volume.setVolume(volume);
      this.socket();
   }
}

class Current {
   constructor() {
      this.initied = false;
   }

   set(data) {
      Object.assign(this, data);
   }

   initialize() {
      this.initiedAt = Date.now();
      this.initied = true;
   }

   destroy() {
      for (let prop in this) {
         if (this.hasOwnProperty(prop)) {
            delete this[prop];
         }
      }
      this.initied = false;
   }
}

module.exports = Queue;
